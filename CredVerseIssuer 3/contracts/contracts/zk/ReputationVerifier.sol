// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import { AccessControl } from "@openzeppelin/contracts/access/AccessControl.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { IGroth16Verifier } from "./IGroth16Verifier.sol";

/**
 * PRD v2.0 aligned contract for zk proof verification on Polygon zkEVM.
 * Accepts Groth16 proof points generated by snarkjs/circom pipelines.
 */
contract ReputationVerifier is AccessControl, ReentrancyGuard {
    bytes32 public constant PROOF_ADMIN_ROLE = keccak256("PROOF_ADMIN_ROLE");

    // circuitId => verifier
    mapping(uint256 => IGroth16Verifier) public zkVerifierByCircuit;
    // circuitId => expected public signal length
    mapping(uint256 => uint256) public expectedPublicSignalsLength;

    struct NullifierConfig {
        bool enabled;
        uint256 index;
    }
    // circuitId => nullifier config
    mapping(uint256 => NullifierConfig) public circuitNullifierConfig;
    // circuitId => nullifier => used
    mapping(uint256 => mapping(uint256 => bool)) public nullifiers;

    mapping(bytes32 => bool) public proofExists;

    event ZkVerifierUpdated(uint256 indexed circuitId, address indexed oldVerifier, address indexed newVerifier, address updatedBy);
    event ExpectedPublicSignalsLengthUpdated(uint256 indexed circuitId, uint256 oldLength, uint256 newLength, address updatedBy);
    event ProofVerified(bytes32 indexed proofHash, address indexed submitter, uint256 indexed circuitId);
    event NullifierUsed(uint256 indexed circuitId, uint256 nullifier);
    event NullifierConfigUpdated(uint256 indexed circuitId, bool enabled, uint256 index);

    error InvalidVerifier();
    error InvalidProof();
    error InvalidCircuitId(uint256 circuitId);
    error PublicSignalsLengthMismatch(uint256 circuitId, uint256 expected, uint256 actual);
    error ProofAlreadyStored(bytes32 proofHash);
    error NullifierAlreadyUsed(uint256 nullifier);
    error InvalidNullifierIndex(uint256 index, uint256 length);

    constructor(address scoreThresholdVerifier, address ageVerificationVerifier, address crossVerticalAggregateVerifier) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PROOF_ADMIN_ROLE, msg.sender);

        _setCircuitVerifier(1, scoreThresholdVerifier);
        _setCircuitVerifier(2, ageVerificationVerifier);
        _setCircuitVerifier(3, crossVerticalAggregateVerifier);

        // public inputs include circuitId + circuit-specific inputs
        _setExpectedPublicSignalsLength(1, 3); // [circuitId, threshold, commitment]
        _setExpectedPublicSignalsLength(2, 3); // [circuitId, cutoffDate, commitment]
        _setExpectedPublicSignalsLength(3, 5); // [circuitId, minVerticals, minScorePerVertical, minAverageScore, commitment]
    }

    function setCircuitVerifier(uint256 circuitId, address verifierAddress) external onlyRole(PROOF_ADMIN_ROLE) {
        _setCircuitVerifier(circuitId, verifierAddress);
    }

    function setExpectedPublicSignalsLength(uint256 circuitId, uint256 newLength) external onlyRole(PROOF_ADMIN_ROLE) {
        _setExpectedPublicSignalsLength(circuitId, newLength);
    }

    function setCircuitNullifierConfig(uint256 circuitId, bool enabled, uint256 index) external onlyRole(PROOF_ADMIN_ROLE) {
        if (!_isSupportedCircuit(circuitId)) revert InvalidCircuitId(circuitId);
        circuitNullifierConfig[circuitId] = NullifierConfig(enabled, index);
        emit NullifierConfigUpdated(circuitId, enabled, index);
    }

    function _setCircuitVerifier(uint256 circuitId, address verifierAddress) internal {
        if (!_isSupportedCircuit(circuitId)) revert InvalidCircuitId(circuitId);
        if (verifierAddress == address(0)) revert InvalidVerifier();

        address old = address(zkVerifierByCircuit[circuitId]);
        zkVerifierByCircuit[circuitId] = IGroth16Verifier(verifierAddress);
        emit ZkVerifierUpdated(circuitId, old, verifierAddress, msg.sender);
    }

    function _setExpectedPublicSignalsLength(uint256 circuitId, uint256 newLength) internal {
        if (!_isSupportedCircuit(circuitId)) revert InvalidCircuitId(circuitId);
        uint256 oldLength = expectedPublicSignalsLength[circuitId];
        expectedPublicSignalsLength[circuitId] = newLength;
        emit ExpectedPublicSignalsLengthUpdated(circuitId, oldLength, newLength, msg.sender);
    }

    function _isSupportedCircuit(uint256 circuitId) internal pure returns (bool) {
        return circuitId >= 1 && circuitId <= 3;
    }

    /**
     * circuitId public signal convention:
     * 1=score_threshold, 2=age_verification, 3=cross_vertical_aggregate
     */
    function verifyAndStoreProof(
        uint256[2] calldata pA,
        uint256[2][2] calldata pB,
        uint256[2] calldata pC,
        uint256[] calldata pubSignals
    ) external nonReentrant returns (bool) {
        if (pubSignals.length == 0) revert InvalidCircuitId(0);

        uint256 circuitId = pubSignals[0];
        if (!_isSupportedCircuit(circuitId)) revert InvalidCircuitId(circuitId);

        uint256 expectedLength = expectedPublicSignalsLength[circuitId];
        if (pubSignals.length != expectedLength) {
            revert PublicSignalsLengthMismatch(circuitId, expectedLength, pubSignals.length);
        }

        IGroth16Verifier verifier = zkVerifierByCircuit[circuitId];
        bool isValid = verifier.verifyProof(pA, pB, pC, pubSignals);
        if (!isValid) revert InvalidProof();

        // Check Nullifier
        NullifierConfig memory nullifierConfig = circuitNullifierConfig[circuitId];
        if (nullifierConfig.enabled) {
            if (nullifierConfig.index >= pubSignals.length) {
                revert InvalidNullifierIndex(nullifierConfig.index, pubSignals.length);
            }
            uint256 nullifier = pubSignals[nullifierConfig.index];
            if (nullifiers[circuitId][nullifier]) {
                revert NullifierAlreadyUsed(nullifier);
            }
            nullifiers[circuitId][nullifier] = true;
            emit NullifierUsed(circuitId, nullifier);
        }

        bytes32 proofHash = keccak256(abi.encodePacked(pA, pB, pC, pubSignals));
        if (proofExists[proofHash]) revert ProofAlreadyStored(proofHash);
        proofExists[proofHash] = true;

        emit ProofVerified(proofHash, msg.sender, circuitId);
        return true;
    }
}
